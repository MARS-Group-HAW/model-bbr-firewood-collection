model KruegerNationalPark

use Mars 

raster-layer Temperature as temperature
raster-layer Precipitation as precipitation

layer SavannaLayer

enum TreeStateType { Seedling Juvenile Adult Death }

enum GenderType { Male Female }

enum DamageType { No Light Moderate Heavy Extreme }

agent Tree on SavannaLayer {
	var IsAlive : bool
	
	static var AN = "an"
	static var CA = "ca"
	static var SB = "sb"
	static var TT = "tt"
	
	external observe var TreeType : string
	external observe var StemDiameter : real
	external observe var StemHeight : real

	observe var HasLeaves : bool

	observe var LivingWoodMass : real
	observe var DeadWoodMass : real
	
	static var DaysPerYear = 365
	static var DaysWithLeaves = 228
	static var E = 2.718281828459045
	static var PI : real = 3.14159265359
    static var EarthRadiusInMeters = 6378100.0;
	
	static var SeedlingsSpawnRatePerYear = 50

	observe var MyDamageType : DamageType = DamageType.No
	var MyTreeStateType : TreeStateType = TreeStateType.Seedling;

	var IsMultiStem : bool
	var WaterHousehold : real
	var ResproutCapacity : real

	def TreePosition() => return #(xcor, ycor)
	
	def CalculateHeigth() : real => return 11.043 * StemDiameter + 88.326
	def CalculateDiameter() : real => return (StemHeight - 88.326) / 11.043
	
	initialize {
		StemHeight = CalculateHeigth
	}
	
	passive TakeDeadWoodMass(mass : real) {
		var result : real 
		if (mass < DeadWoodMass) {
			result = mass
		} else {
			result = DeadWoodMass
		}
		DeadWoodMass = DeadWoodMass - result
		return result
	}

	passive TakeLivingWoodMass(mass : real) {
		//TODO 1 cm diameter und 100cm height bleiben auf jeden Fall!
		var currentLivingWoodMass = CalculateLivingWoodMass
		var result : real
		
		if (mass < currentLivingWoodMass) {
			result = mass
		} else {
			result = currentLivingWoodMass
		}
		MyDamageType = CalculateDamageType(result)
		LivingWoodMass = LivingWoodMass - result
		
//TODO		StemDiameter = CalculateDiameterBy(LivingWoodMass)
		return result
	}
	
	//	def CalculateLivingWoodMass() : real => return Math.Exp(intermediate = -3.39 + 2.883 * Math.Log(StemDiameter, E), E) / 60 * 100 
 // def CalculateDiameterBy(woodMass : real) => return Math.exp((100/60* Math.Log(woodmass, E) + 3.39 )/ 2.83, E)
//TODO testen
	
	def CalculateDamageType (result : real) {
		if (result / LivingWoodMass > 0.9) {
			return DamageType.Extreme
		} else if (result / LivingWoodMass > 0.1) {
			return DamageType.Moderate
		}
		return DamageType.No
	}

	def UpdatePhotosyntheseActive() { // SUM: 228 days with leaves
		if (Time::Month(simtime) === 10 and Time::Day(simtime) === 15)
			HasLeaves = true
		else if (Time::Month(simtime) === 6 and Time::Day(simtime) === 15)
			HasLeaves = false
	}

	def UpdateTreeStateType() {
		if (StemDiameter >= 1) {
			if (IsJuvenileByStemDiameter) {
				MyTreeStateType = TreeStateType.Juvenile;
			} else {
				MyTreeStateType = TreeStateType.Adult;
			}
		}		
	}
	
	def IsJuvenileByStemDiameter() {
		if (TreeType === AN) {
			return StemDiameter < 8
		} else if (TreeType === CA) {
			return StemDiameter < 10
		} else if (TreeType === SB) {
			return StemDiameter < 20
		} else if (TreeType === TT) {
			return StemDiameter < 13
		}
	}

	tick {
		UpdateTreeStateType
		UpdatePhotosyntheseActive
		
		if (MyTreeStateType === TreeStateType.Seedling) {
			Seedling
		} else if (MyTreeStateType === TreeStateType.Juvenile) {
			Juvenile
		} else if (MyTreeStateType === TreeStateType.Adult) {
			Adult
		}
		ResetDamageType
		
//		println simtime + ": " + xcor + "," + ycor + " diameter:" +StemDiameter + " type:"+ TreeType
	}
	
	def Seedling() {	
		var tempToday = temperature.GetNumberValue(ycor, xcor)	
		if(tempToday < 0 and RandomPropabilitySmallenThan(80)) {
			Die //TODO Ausdiffernziertes Baummodell: Arten unterschiedlich
		} else if (MyDamageType !== DamageType.No) {
			Die
		} else if (HasLeaves) {
			GrowSeedling
		} 		
	}

	def Juvenile() {
		if (HasLeaves) {
			if (MyDamageType !== DamageType.No) {
				GrowResprouting
			} else {
				GrowJuvenile
			}
		} 
	}

	def Adult() {
		if (HasLeaves) {
			if (MyDamageType === DamageType.No) {
				Grow(1)
			} else if (MyDamageType === DamageType.Light) {
				Grow(ReducedTo(90, 100))
			} else if (MyDamageType === DamageType.Moderate) {
				Grow(ReducedTo(70, 90)) 
			} else if (MyDamageType === DamageType.Heavy) {
				Grow(ReducedTo(40, 70))
			} else if (MyDamageType === DamageType.Extreme) {
				GrowResprouting
			}
		} 
		if (Time::Month(simtime) === 3 and Time::Day(simtime) === 15) {
			SpawnSeedlings
		}
	}
	
	def SpawnSeedlings() {
		for (var i = 0; i < SeedlingsSpawnRatePerYear; i++) {
			var seedling = spawn Tree at GetRelativePosition(ycor, xcor, random(50), random(360))
			seedling.SetTreeType(TreeType)		
		} 
	}
	
	passive SetTreeType(treeType : string) {
		TreeType = treeType	
	}
		
	def GrowSeedling() {
		StemDiameter = StemDiameter + StemDiameter / DaysWithLeaves
	}
	
	def GrowResprouting() {
		GrowJuvenile
	}
	
	def GrowJuvenile() {
		if (TreeType === AN) {
			GrowAnJuvenile
		} else if (TreeType === CA) {
			GrowCaJuvenile
		} else if (TreeType === SB) {
			GrowSbJuvenile
		} else if (TreeType === TT) {
			GrowTtJuvenile
		}
	}
	
	def GrowAnJuvenile() {
		StemHeight = StemHeight + RandomBetween(11, 36) / DaysWithLeaves
		StemDiameter = CalculateDiameter
	}
	
	def GrowCaJuvenile() {
		StemDiameter = StemDiameter + (0.08 * StemDiameter + 0.089856) / DaysWithLeaves
		StemHeight = CalculateHeigth
	}
	
	def GrowSbJuvenile() {
		StemDiameter = StemDiameter + (-0.068 * StemDiameter + 4.54) / DaysWithLeaves
		StemHeight = CalculateHeigth
	}
	
	def GrowTtJuvenile() {
		StemDiameter = StemDiameter + 1 / DaysWithLeaves
		StemHeight = CalculateHeigth
	}
		
	def Grow(reduceFactor: real) {
		if (TreeType === AN) {
			GrowAn(reduceFactor)
		} else if (TreeType === CA) {
			GrowCa(reduceFactor)
		} else if (TreeType === SB) {
			GrowSb(reduceFactor)
		} else if (TreeType === TT) {
			GrowTt(reduceFactor)
		}
		
		//TODO Ausdiffernziertes Baummodell: UmwelteinflÃ¼sse verkleinern growthrate
		var mytemp = temperature.GetNumberValue(ycor, xcor)	
		var myPrec = precipitation.GetNumberValue(ycor, xcor)	
	}
	
	def GrowAn(reduceFactor : real) {
		StemDiameter = StemDiameter + 0.04 / DaysWithLeaves * reduceFactor
		StemHeight = StemHeight + (1 - StemHeight/16) * RandomBetween(11, 32) / DaysWithLeaves * reduceFactor	 	
	}
	
	def GrowCa(reduceFactor : real) {
		StemDiameter = StemDiameter + 0.03 / DaysWithLeaves * reduceFactor
		StemHeight = StemHeight + (1 - StemHeight/RandomBetween(3, 10)) * 0.5 / DaysWithLeaves * reduceFactor		
	}
	
	def GrowSb(reduceFactor : real) {
		StemDiameter = StemDiameter + 0.05 / DaysWithLeaves * reduceFactor
		StemHeight = StemHeight + (1 - StemHeight/18) * RandomBetween(50, 150) / DaysWithLeaves * reduceFactor		
	}
	
	def GrowTt(reduceFactor : real) {
		StemDiameter = StemDiameter + (0.04 / DaysWithLeaves) * reduceFactor
		StemHeight = StemHeight + (1 - StemHeight/10) * RandomBetween(1, 150) / DaysWithLeaves * reduceFactor		
	}	
	
 	def CalculateLivingWoodMass() : real {
 		if (TreeType === AN) {
			return E ** ( -3.55 + 3.06* Math.Log(StemDiameter, E))
		} else if (TreeType === CA) {
			return E ** ( -3.27 + 2.8* Math.Log(StemDiameter, E))
		} else if (TreeType === SB) {
			return E ** ( -3.35 + 2.62* Math.Log(StemDiameter, E))
		} else if (TreeType === TT) {
			return E ** ( -3.39 + 2.827* Math.Log(StemDiameter, E))
		}
	}
	
	def GenerateDeadwoodMass() {
		return 0.017 * LivingWoodMass / DaysPerYear
	}
	
	def Die() {
		MyTreeStateType = TreeStateType.Death
		IsAlive = false
	}
		
	def ResetDamageType() {
		MyDamageType = DamageType.No	 
	}	
	
	static def Reduce(growthrate : real, min : integer, max : integer) {
		return growthrate * (min + RandomBetween(min, max)) / 100 
	}
		
	static def RandomPropabilitySmallenThan(percentage : integer) {
		return random(100) < percentage
	}
	
	static def RandomBetween(min : integer, max : integer) : real {
		return random(max + 1 - min) + min 
	}
	
	static def ReducedTo(minPercentage : integer, maxPercentag : integer) : real {
		return RandomBetween(minPercentage, maxPercentag) / 100
	}
    
    def GetRelativePosition(originLatitude : real, originLongitude : real, bearing : real, distanceInM  : real)  {
    	var DegreesToRadians : real = PI / 180.0
    	var RadiansToDegrees : real = 180.0 / PI
    	var latA : real = DegreesToRadians * originLatitude
    	var lonA : real = originLongitude * DegreesToRadians

    	var radBearing = bearing * DegreesToRadians
		var cosB : real = Math.Cos(distanceInM / EarthRadiusInMeters)
		var cosLatB : real =  Math.Cos(latA)

		var SinLatA : real = Math.Sin(latA)
		var sinB : real = Math.Sin(distanceInM / EarthRadiusInMeters)
		var cosBearing : real = Math.Cos(radBearing)
		var temp1 : real = SinLatA * cosB 
		var temp2 : real = 0
       	var lat = Math.Asin(temp1+ cosLatB * sinB * cosBearing)
		var SinLat : real = Math.Sin(lat)
       	var sindBearing : real = Math.Sin(radBearing)
       	
       	var atan1 : real = sindBearing * Math.Sin(distanceInM / EarthRadiusInMeters) * Math.Cos(latA)
       	
       	var cosDistance = Math.Cos(distanceInM / EarthRadiusInMeters)
       	var atan2 : real = cosDistance - SinLatA * SinLat
		var lon = lonA + Math.Atan2(atan1, atan2)

		var latResult : real = lat * RadiansToDegrees
		var lonResult : real = lon * RadiansToDegrees
		
		return #(lonResult, latResult)
     }
}
