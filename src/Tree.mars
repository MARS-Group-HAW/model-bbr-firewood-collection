model KruegerNationalPark

use Mars 

raster-layer Temperature as temperature
raster-layer Precipitation as precipitation

layer SavannaLayer

enum TreeStateType { Seedling Juvenile Adult Death }

enum GenderType { Male Female }

enum DamageType { No Light Moderate Heavy Extreme }

agent Tree on SavannaLayer {
	var IsAlive : bool
	
	static var AN = "an"
	static var CA = "ca"
	static var SB = "sb"
	static var TT = "tt"
	external var TreeType : string
	external var StemDiameter : real

	observe var HasLeaves : bool

	observe var LivingWoodMass : real
	observe var DeadWoodMass : real
	
	static var DaysPerYear = 365
	static var DaysWithLeaves = 228
	static var E = 2.718281828459045
	static var PI : real = 3.172
    static var EarthRadiusInMeters = 6378100.0;
	
	static var SeedlingsSpawnRatePerYear = 50
	
	var SeedlingGrowthrate : real = 0
	var SeedlingGrowthrateOffset : real = 1 
	
	var Growthrate : real = 0// -0.068//0.08
	var GrowthrateOffset : real = 0// 34.54//0.089856
	
	var ResproutGrowthrate : real = 5

	observe var MyDamageType : DamageType = DamageType.No
	var MyTreeStateType : TreeStateType = TreeStateType.Seedling;

	var IsMultiStem : bool
	var WaterHousehold : real
	var ResproutCapacity : real

	def TreePosition() => return #(xcor, ycor)
	
	def Heigth() => return 11.043 * StemDiameter + 88.326
	
//	def CalculateLivingWoodMass() : real => return Math.Exp(intermediate = -3.39 + 2.883 * Math.Log(StemDiameter, E), E) / 60 * 100 
 // def CalculateDiameterBy(woodMass : real) => return Math.exp((100/60* Math.Log(woodmass, E) + 3.39 )/ 2.83, E)
//TODO testen

 	def CalculateLivingWoodMass() => return  E * E * (-3.39 + 2.883 * Math.Log(StemDiameter, E)) / 60 * 100 

	passive TakeDeadWoodMass(mass : real) {
		var result : real if (mass < DeadWoodMass) {
			result = mass
		} else {
			result = DeadWoodMass
		}
		DeadWoodMass = DeadWoodMass - result
		return result
	}

	passive TakeLivingWoodMass(mass : real) {
		var currentLivingWoodMass = CalculateLivingWoodMass
		var result : real
		
		if (mass < currentLivingWoodMass) {
			result = mass
		} else {
			result = currentLivingWoodMass
		}
		MyDamageType = CalculateDamageType(result)
		LivingWoodMass = LivingWoodMass - result
		
//TODO		StemDiameter = CalculateDiameterBy(LivingWoodMass)
		return result
	}
	
	def CalculateDamageType (result : real) {
		if (result / LivingWoodMass > 0.9) {
			return DamageType.Extreme
		} else if (result / LivingWoodMass > 0.1) {
			return DamageType.Moderate
		}
		return DamageType.No
	}

	def UpdatePhotosyntheseActive() { // SUM: 228 days with leaves
		if (Time::Month(simtime) === 10 and Time::Day(simtime) === 15)
			HasLeaves = true
		else if (Time::Month(simtime) === 6 and Time::Day(simtime) === 15)
			HasLeaves = false
	}

	def UpdateTreeStateType() {
		if (StemDiameter > 1 and StemDiameter < 10) {
			MyTreeStateType = TreeStateType.Juvenile;
		} else if  (StemDiameter >= 10) {
			MyTreeStateType = TreeStateType.Adult;
		}
	}

	tick {
		UpdateTreeStateType
		UpdatePhotosyntheseActive
		
		if (TreeStateType.Seedling === MyTreeStateType) {
			Seedling
		} else if (TreeStateType.Juvenile === MyTreeStateType) {
			Juvenile
		} else if (TreeStateType.Adult === MyTreeStateType) {
			Adult
		}
		ResetDamageType
		
		println simtime + "," + xcor + "," + ycor
		spawn Tree at GetNewPositionBy(ycor, xcor, 50, 0)	    
	}
	
	def Seedling() {
		println "Seedling"
		
		var tempToday = temperature.GetNumberValue(ycor, xcor)	
		if(tempToday < 0 and RandomPropabilitySmallenThan(80)) {
			Die //TODO Ausdiffernziertes Baummodell: Arten unterschiedlich
		} else if (MyDamageType !== DamageType.No) {
			Die
		} else if (HasLeaves) {
			Grow(SeedlingGrowthrate, SeedlingGrowthrateOffset)
		} 		
	}
	
	def RandomPropabilitySmallenThan(percentage : integer) {
		return random(100) < percentage
	}

	def Juvenile() {
		println "Juvenile"
		if (HasLeaves) {
			if (MyDamageType !== DamageType.No) {
				Grow(ResproutGrowthrate, GrowthrateOffset)
			} else {
				Grow(Growthrate, GrowthrateOffset)
			}
		} 
	}

	def Adult() {
		println "Adult"
		if (HasLeaves) {
			if (MyDamageType === DamageType.No) {
				Grow(Growthrate, GrowthrateOffset)
			} else if (MyDamageType === DamageType.Light) {
				Grow(Reduce(Growthrate, 90, 100), GrowthrateOffset)
			} else if (MyDamageType === DamageType.Moderate) {
				Grow(Reduce(Growthrate, 70, 90), GrowthrateOffset)
			} else if (MyDamageType === DamageType.Heavy) {
				Grow(Reduce(Growthrate, 40, 70), GrowthrateOffset)
			} else if (MyDamageType === DamageType.Extreme) {
				Grow(ResproutGrowthrate, GrowthrateOffset)
			}
		} 
		if (Time::Month(simtime) === 3 and Time::Day(simtime) === 15) {
			SpawnSeedlings
		}
	}
	
	def SpawnSeedlings() {
		for (var i = 0; i < SeedlingsSpawnRatePerYear; i++) {
			spawn Tree at GetNewPositionBy(ycor, xcor, 50, 0)
		} //TODO testen: wo ist das?
	}
	
	def Grow(growthrate : real, growthrateOffset : real) {
		//TODO Ausdiffernziertes Baummodell: Umwelteinflüsse verkleinern growthrate
		var mytemp = temperature.GetNumberValue(ycor, xcor)	
		var myPrec = precipitation.GetNumberValue(ycor, xcor)	
		
		//TODO Juvenils: nur diameter bildet Wachstum ab, Höhe lässt sich daraus direkt berechnen
		//TODO Adults: diamter und heigth sind unabhängige Variablen (siehe Mail-Formeln)
		
		StemDiameter = StemDiameter + (growthrate * StemDiameter + growthrateOffset) / DaysWithLeaves
		
		DeadWoodMass = DeadWoodMass + GenerateDeadwoodMass
	}	
	
	def GenerateDeadwoodMass() {
		return 0.017 * LivingWoodMass / DaysPerYear
	}
	
	def Die() {
		MyTreeStateType = TreeStateType.Death
		IsAlive = false
	}
		
	def ResetDamageType() {
		MyDamageType = DamageType.No	 
	}	
	
	static def Reduce(growthrate : real, min : integer, max : integer) {
		return growthrate * (min + random(max - min)) / 100 
	}
	
	def GetNewPositionBy(lat : real, lon : real, distanceInM : real, bearing : real) {
		var radian = bearing * PI / 180
        var angularDistance = distanceInM / EarthRadiusInMeters
            
        var sinLat : real = Math.Sin(lat)
        var cosLat : real =  Math.Cos(lat)
        var cosAngularDistance : real = Math.Cos(angularDistance)
        var sinAngularDistance : real = Math.Sin(angularDistance)
        var cosRadian : real = Math.Cos(radian)
        var firstPart : real = sinLat * cosAngularDistance;
        var secondPart : real = cosLat * sinAngularDistance * cosRadian
        var temp = firstPart + secondPart
        var destLat : real = Math.Asin(temp);
            
        var sinRadian : real = Math.Sin(radian) 
        var sinDestLat : real = Math.Sin(destLat)
        var thirdPart : real = sinLat * sinDestLat

        var destLon : real = lon 
//            var destLon : real = lon + Math.Atan2(sinRadian * sinAngularDistance * Math.Cos(lat), Math.Cos(angularDistance) - thirdPart)

        destLon = (destLon + 3 * PI) % (2 * PI) - PI; // Normalisierung zu -180..+180º

        return #(destLat, destLon);
    }
}
